# CPU의 작동 원리

1장에서 언급된 ALU와 제어장치에 대해 학습.

ALU와 제어장치가 받아들이고 내보내는 정보를 기준으로 각 부품의 역할을 설명

## [ALU (산술논리연산장치, Arithmetic Logic Unit)](https://ko.wikipedia.org/wiki/%EC%82%B0%EC%88%A0_%EB%85%BC%EB%A6%AC_%EC%9E%A5%EC%B9%98)

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled.png)

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%201.png)

계산만을 위해 존재하는 부품, 컴퓨터 내부에서 수행되는 대부분의 계산을 도맡아함

레지스터를 통해 **피연산자**를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 **제어 신호**를 받아들인다.

⇒ 단순 연산 (사칙연산, 비트 논리 연산`(AND, NOT, OR, XOR)`, 비트 시프트 연산`(JS기준 >> 혹은 <<)`) 또는 복합연산

- CPU → 레지스터 → 메모리 → SSD || HDD (속도 내림차순으로 접근)

### ALU 플래그 정보

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%202.png)

연산결과에 대한 추가적인 상태 정보 (`ex. 음수를 표현할때 등`), **플래그 레지스터**에 저장

- **부호 플래그** : 연산한 결과의 **부호**를 나타낸다.
- **제로 플래그** : 연산 결과가 **0인지 여부**를 나타낸다.
- **캐리 플래그** : 연산 결과 **올림수**나 **빌림수**가 발생했는지를 나타낸다.
- **오버플로우 플래그** : **오버플로우가 발생**했는지를 나타낸다.
- **인터럽트 플래그** : **인터럽트가 가능**한지는 나타낸다. (링크)
- **슈퍼바이저 플래그** : **커널 모드** 또는 **사용자 모드**로 실행중인지 나타낸다. (링크)

---

## [제어장치 (CU: Control Unit)](https://www.assignmenthelp.net/assignment_help/what-is-control-unit)

`**제어신호 (control signal)**`라는 전기 신호를 내보내고 명령어를 해석하는 장치.

<aside>
💡 CPU 제조사 별 제어장치의 구현 방식 또는 명령어 해석 및 받아들이고 내보내는 정보의 차이가 있으므로 역할에 대해 이해하는데 중점을 두자 !

</aside>

제어신호란 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기신호.

- **예시 1** - CPU가 메모리에 저장된 값을 읽고 싶을 땐 메모리를 향해 **메모리 읽기**라는 제어 신호를 보낸다.
- **예시 2** - CPU가 메모리에 어떤 값을 저장하고 싶을 땐 메모리를 향해 **메모리 쓰기**라는 제어 신호를 보낸다.

- **참고 그림**
  ![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%203.png)

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%204.png)

1. `**클럭 신호**`를 받아들인다.

- 1-1) 클럭(clock) 이란 ?

<aside>
💡 컴퓨터의 모든 부품을 움직일 수 있게 하는 시간단위.

</aside>

- 클럭의 주기에 맞춰 레지스터 간 데이터 이동 및 ALU에서 연산을 수행하고 CPU가 메모리에 저장된 명령어를 읽게 한다.

2. `**해석해야 할 명령어**`(현재 수행할 명령어)를 받아들인다.

- 명령어 레지스터에 저장되어있는 해석할 명령어를 받아 해석한 뒤 제어신호를 발생하여 **수행할 내용**을 알려준다.

3. `**플래그 레지스터 속 플래그 값**`을 받아들인다.

- **플래그**(ALU 연산에 추가적인 상태정보)를 참고하여 제어신호를 발생시킨다.
- 3-1) 이때, 경우에 따라 CPU내부 또는 외부에 전달한다.

4. 시스템 버스, 그중 `**제어 버스로 전달된 제어 신호**`를 받아들인다.

- **제어 신호**는 CPU뿐만 아니라 입출력장치를 비롯한 CPU 외부 장치도 발생시킬수 있는데, 제어장치는 제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들이기도 한다.

### 내보내는 정보

- CPU 외부에 전달하는 제어 신호

  - 크게 메모리에 전달하는 제어신호와 입출력장치(**보조기억장치 포함**)에 전달하는 제어신호로 나눌 수 있다.
  - 메모리 - 메모리에 제어신호를 보낸다.
  - 입출력장치 - 입출력장치에 제어신호를 보낸다.

- CPU 내부에 전달하는 제어 신호
  - 크게 ALU에 전달하는 제어 신호와 레지스터에 전달하는 제어신호로 나눌 수 있다.
  - ALU - **수행할 연산을 지시**하기 위해 제어 신호를 보낸다.
  - 레지스터 - 레지스터 간 **데이터 이동 또는 저장된 명령어를 해석**하기 위해 제어 신호를 보낸다.

---

## [레지스터 (register)](https://github.com/kangtegong/self-learning-cs/blob/main/registers/registers.md)

- [참고자료](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C_%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0)
  - **데이터 레지스터** : 정수 값을 저장
  - **주소 레지스터** : 메모리 주소를 저장하여 메모리 접근에 사용 `(프로세서 종류에 따라 주소가 아닌 조작을 위한 목적으로 **색인 레지스터**로 사용)`
  - **범용 레지스터** : 데이터와 주소를 모두 저장할 수 있는 레지스터.
  - **부동소수점 레지스터** : 많은 시스템에서 **부동소수점** 값을 저장하기 위해 사용
  - **상수 레지스터** : 0이나 1 등 고정된 값을 저장하고 있는 레지스터.
  - **특수 레지스터** : 프로그램의 상태를 저장 `(프로그램 카운터, 스택 포인터, 상태 레지스터 등)`
    - **명령 레지스터** : 현재 실행중인 명령어를 저장
    - **색인 레지스터** : 실행중에 피연산자의 주소를 계산하는 데 사용

CPU 내부의 작은 임시 저장 장치, 프로그램을 실행하는 데 필요한 값들을 임시로 저장.

CPU 안에 여러 개의 레지스터가 존재하며 각각 다른 이름과 역할을 가지고 있다.

⇒ CPU는 메모리에 저장된 값을 읽어 들이고, 해석하고, 실행하는 장치다.

⇒ CPU 내부에는 ALU, 레지스터, 제어장치가 있다.

⇒ ALU는 계산하는 장치, 레지스터는 임시 저장 장치, 제어장치는 제어 신호를 발생시키고 명령어를 해석하는 장치다.

### **FLOW**

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%205.png)

- 프로그램 카운터 (PC: Program Counter) : 메모리에서 **가져올** **명령어 주소 저장**, 명령어 포인터 (IP: Instruction Pointer)라고 부르는 CPU도 있다. 변위 주소 지정 방식을 사용

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%206.png)

- 메모리 주소 레지스터 (MAR: Memory Address Register) : **메모리의 주소**를 저장.

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%207.png)

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%208.png)

- 메모리 버퍼 레지스터 (MBR: Memory Buffer Register) : 메모리와 주고받을 **데이터와 명령어를 저장**. 메모리 데이터 레지스터 (MDR: Memory Data Register) 라고도 한다.

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%209.png)

- 명령어 레지스터 (IR: Instruction Register) : **해석할 명령어**를 저장.

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%2010.png)

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%2011.png)

<aside>
💡 명령어 레지스터에서 처리가 끝나면 프로그램 카운터가 변하고 1번의 순서부터 다시 시작된다.
주소를 저장 - 프로그램 카운터, 메모리 주소 레지스터
데이터(혹은 명령어)를 저장 - 메모리 버퍼 레지스터, 명령어 레지스터

</aside>

- 범용 레지스터 (general purpose register) : 다른 레지스터와는 다르게 데이터(혹은 명령어)와 주소 모두 저장가능.
- 플래그 레지스터 (flag register) : 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장.
- 스택 포인터 (stack pointer) : 스택 주소 지정 방식을 사용
- 베이스 레지스터 : 변위 주소 지정 방식을 사용

---

## 주소 지정 방식

### 스택 주소 지정 방식

스택과 스택 포인터를 이용한 주소 지정 방식. (LIFO, Last In First Out)

스택포인터 - 스택의 마지막 값의 위치를 저장하는 레지스터

프로그램 카운터의 값이 증가하며 다음 주소를 가리키듯, 스택포인터의 값이 완료되면 그 다음 값을 가리킨다.

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%2012.png)

### 변위 주소 지정 방식

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%2013.png)

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%2014.png)

오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식.

오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 **상대 주소 지정, 베이스 레지스터 주소 지정 방식** 등으로 나뉜다.

- 변위 주소 지정 방식의 종류
    <aside>
    💡 프로세서가, 기억장치 접근을 위해 필요한, 계산 및 접근 횟수 등에 따라 달라짐
    
    </aside>
    
    - 피연산자(오퍼랜드)에 기억장치 내 위치(유효 주소)를 지정하는 방식
        - 유효 주소 : 주소 지정방식에 의해 결정되는 오퍼랜드의 주소
    - 연산에 필요한 오퍼랜드의 주소를 알아내는데 사용되는 방식
    - 주소필드 저장 형태에 따른 구분
        - 직접 주소 지정 방식 (Direct or Absolute Addressing Mode)
        - 간접 주소 지정 방식 (Indirect Addressing Mode)
        - 묵시적 주소지정 방식, 의미 주소 지정 방식 (Implied or Inherent Addressing Mode)
        - 즉시/즉치 주소 지정 방식 (Immediate or Literal Addressing Mode)
        - 상대 주소 지정 방식 (Relative Addressing Mode)
    - 유효 주소 계산 단계에 따른 구분
        - 0단계 주소 지정 방식  :  유효 주소의 확정을 위해 별도의 계산이 필요 없음
            - 즉치 주소 지정 방식 (Immediate Addressing Mode)
            - 묵시 주소 지정 방식 (Implied Addressing Mode)
        - 1단계 주소 지정 방식  :  유효 주소의 확정을 위해 한 차례의 계산이 필요
            - 직접 주소 지정 (Direct Addressing Mode)
            - 레지스터 직접 주소 지정 (Register-Direct Addressing)
        - 2단계 주소 지정 방식  :  유효 주소의 확정을 위해 두 차례의 계산이 필요(즉, 두 번의 기억장치 접근이 필요)
            - 간접 주소 지정 방식 (Indirect Addressing Mode)
            - 레지스터 간접 주소 지정 (Register-Indirect Addressing Mode)
            - 상대 주소 지정 방식 (Relative Addressing Mode)
            - 변위 주소 지정 방식 (Displacement Addressing)

**상대 주소 지정 방식**

오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식 (프로그래밍 언어 사용시 if문과 유사)

오퍼랜드가 -3 일경우

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%2015.png)

오퍼랜드가 3일경우

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%2016.png)

**베이스 레지스터 주소 지정 방식**

오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%2017.png)

---

## 명령어 사이클과 인터럽트

### 정의

- 명령어 사이클 - CPU가 하나의 명령어를 처리하는 정형화된 흐름
- 인터럽트 - 명령어 사이클 도중 흐름이 끊어지는 상황

### 명령어 사이클

- 인출 사이클 (fetch cycle) - 메모리에서 CPU로 명령어를 가져오는 단계 (위 FLOW 2~6단계)
- 실행 사이클 (execution cycle) - CPU로 가져온 명령어를 실행하는 단계
- 간접 사이클 (indirect cycle) - 간접 주소 지정 방식과 같이 오퍼랜드 필드 메모리에 접근이 한번 더 필요한 경우 추가되는 단계

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%2018.png)

### 인터럽트

- 종류
  - 동기 인터럽트(synchronous interrupts) - CPU에 의해 발생되며 명령어를 수행하다가 오류와 같은 예외적인 상황에 발생, 예외(exception)라고도 부른다.
  - 비동기 인터럽트 (asynchronous interrupts) -입출력장치에 의해 발생하며 특정 작업에 대한 알림과 같은 역할을 한다. 하드웨어 인터럽트 라고도 한다.

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%2019.png)

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%2020.png)

### 하드웨어 인터럽트

입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 사용

**순서**

1. 입출력장치는 CPU에 **인터럽트 요청 신호**를 보낸다.
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.
3. CPU는 인터럽트 요청을 확인하고 **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.
5. CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행한다.
6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해 둔 작업을 복구하여 실행을 재개한다.

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%2021.png)

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%2022.png)

- 인터럽트 요청 신호 - 다른 작업을 진행중인 CPU에 인터럽트 요청하는 신호
- 인터럽트 플래그 - 플래그 레지스터에 인터럽트 플래그에 따라 하드웨어의 인터럽트 수용 여부를 결정
- 인터럽트 서비스 루틴 - 인터럽트를 처리하기 위한 프로그램이며, 어떻게 진행되어야 하는지에 대한 프로그램. 인터럽트 핸들러 라고도 한다.
- 인터럽트 벡터 - 서비스 루틴을 식별하기 위한 정보

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%2023.png)

---

## 예외의 종류

![Untitled](CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5/Untitled%2024.png)

예외 발생시 CPU가 하던 일을 중단하고 예외를 처리한 후 본래 하던 작업으로 되돌아 왔을때 작업방식에 따라 방식이 나뉜다.

- 폴트 - 예외 처리후 예외가 발생한 명령어부터 실행을 재개
- 트랩 - 예외 처리후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개 (ex. 디버깅)
